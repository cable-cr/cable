<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 1.6.2">
<meta name="crystal_docs.project_version" content="0.3.1">
<meta name="crystal_docs.project_name" content="cable">



<link href="css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/doc.js"></script>

  <meta name="repository-name" content="cable">
  <title>cable 0.3.1</title>
  <script type="text/javascript">
  CrystalDocs.base_path = "";
  </script>
</head>
<body>

<svg class="hidden">
  <symbol id="octicon-link" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
  </symbol>
</svg>
<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="project-summary">
      <h1 class="project-name">
        <a href="index.html">
          cable
        </a>
      </h1>

      <span class="project-version">
        0.3.1
      </span>
    </div>
  </div>

  <div class="search-results hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="cable/Cable" data-name="cable">
      <a href="Cable.html">Cable</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/BackendCore" data-name="cable::backendcore">
      <a href="Cable/BackendCore.html">BackendCore</a>
      
    </li>
  
  <li class="parent " data-id="cable/Cable/Channel" data-name="cable::channel">
      <a href="Cable/Channel.html">Channel</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/Channel/CloseRedisFiber" data-name="cable::channel::closeredisfiber">
      <a href="Cable/Channel/CloseRedisFiber.html">CloseRedisFiber</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Cable/Channels" data-name="cable::channels">
      <a href="Cable/Channels.html">Channels</a>
      
    </li>
  
  <li class="parent " data-id="cable/Cable/Connection" data-name="cable::connection">
      <a href="Cable/Connection.html">Connection</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/Connection/UnauthorizedConnectionException" data-name="cable::connection::unauthorizedconnectionexception">
      <a href="Cable/Connection/UnauthorizedConnectionException.html">UnauthorizedConnectionException</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Cable/Debug" data-name="cable::debug">
      <a href="Cable/Debug.html">Debug</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/DevBackend" data-name="cable::devbackend">
      <a href="Cable/DevBackend.html">DevBackend</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/HabitatSettings" data-name="cable::habitatsettings">
      <a href="Cable/HabitatSettings.html">HabitatSettings</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Handler" data-name="cable::handler(t)">
      <a href="Cable/Handler.html">Handler</a>
      
    </li>
  
  <li class="parent " data-id="cable/Cable/Payload" data-name="cable::payload">
      <a href="Cable/Payload.html">Payload</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/Payload/IdentifierConverter" data-name="cable::payload::identifierconverter">
      <a href="Cable/Payload/IdentifierConverter.html">IdentifierConverter</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Payload/Indentifier" data-name="cable::payload::indentifier">
      <a href="Cable/Payload/Indentifier.html">Indentifier</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Payload/PARAMS" data-name="cable::payload::params">
      <a href="Cable/Payload/PARAMS.html">PARAMS</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Payload/RESULT" data-name="cable::payload::result">
      <a href="Cable/Payload/RESULT.html">RESULT</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Cable/RedisBackend" data-name="cable::redisbackend">
      <a href="Cable/RedisBackend.html">RedisBackend</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/RedisPinger" data-name="cable::redispinger">
      <a href="Cable/RedisPinger.html">RedisPinger</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/RemoteConnections" data-name="cable::remoteconnections">
      <a href="Cable/RemoteConnections.html">RemoteConnections</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Server" data-name="cable::server">
      <a href="Cable/Server.html">Server</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/WebsocketPinger" data-name="cable::websocketpinger">
      <a href="Cable/WebsocketPinger.html">WebsocketPinger</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1><a id="cable" class="anchor" href="#cable">  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Cable</h1>
<p><a href="https://github.com/cable-cr/cable/actions/workflows/ci.yml"><img src="https://github.com/cable-cr/cable/actions/workflows/ci.yml/badge.svg" alt="ci workflow" /></a></p>
<p>It's like <a href="https://guides.rubyonrails.org/action_cable_overview.html">ActionCable</a> (100% compatible with JS Client), but you know, for Crystal.</p>
<h2><a id="installation" class="anchor" href="#installation">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Installation</h2>
<ol>
<li>Add the dependency to your <code>shard.yml</code>:</li>
</ol>
<blockquote>
<p><span class="flag purple">NOTE</span>  You must explicitly add the Redis shard also.</p>
</blockquote>
<pre><code class="language-yaml">dependencies:
  cable:
    github: cable-cr/cable
    branch: master # or use the latest version
  redis:
    github: jgaskins/redis
    branch: master # lock down if needed</code></pre>
<blockquote>
<p><span class="flag purple">NOTE</span>  You can only use a single Redis shard. We recommend https://github.com/jgaskins/redis. However, you can use the legacy shard https://github.com/stefanwille/crystal-redis.</p>
</blockquote>
<ol start="2">
<li>Run <code>shards install</code></li>
</ol>
<h2><a id="usage" class="anchor" href="#usage">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Usage</h2>
<p>Application code</p>
<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;cable&quot;</span>
<span class="k">require</span> <span class="s">&quot;cable/backend/redis/backend&quot;</span></code></pre>
<h2><a id="backend-setup" class="anchor" href="#backend-setup">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Backend setup</h2>
<p>At the moment, we only support a Redis backend.</p>
<h3><a id="redis" class="anchor" href="#redis">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Redis</h3>
<p>Due to some stability issues, we recently swapped the Redis shard.</p>
<p>To offer backwards compatibility, we still provide the ability to use the previous legacy shard. However, this may change in the future.</p>
<p><strong>Release 0.3</strong></p>
<p>Moving forward, from this release, we are officially supporting this <a href="https://github.com/jgaskins/redis">Redis shard</a>.</p>
<p>Prior to this release, we used this <a href="https://github.com/stefanwille/crystal-redis">Redis shard</a>.</p>
<p>However, since we cannot use two conflicting shards, we only run tests against our officially supported shard.</p>
<p><strong>Legacy Redis shard usage</strong></p>
<p>You can still choose to continue to use the legacy Redis shards.</p>
<pre><code class="language-yaml">dependencies:
  cable:
    github: cable-cr/cable
  redis:
    github: stefanwille/crystal-redis
    version: ~&gt; 2.8.0 # last tested version</code></pre>
<p>Application code</p>
<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;cable&quot;</span>
<span class="k">require</span> <span class="s">&quot;cable/backend/redis/legacy/backend&quot;</span></code></pre>
<p><strong>Testing the legacy Redis shard</strong></p>
<p>If you want to test the legacy shard locally, change these files;</p>
<pre><code class="language-crystal"><span class="c"># spec/spec_helper.cr</span>

<span class="c"># require &quot;../src/backend/redis/backend&quot;</span>
<span class="k">require</span> <span class="s">&quot;../src/backend/redis/legacy/backend&quot;</span></code></pre>
<pre><code class="language-yaml"># shard.yml

development_dependencies:
  # redis:
  #   github: jgaskins/redis
  #   version: ~&gt; 0.5.0
  redis:
    github: stefanwille/crystal-redis
    version: ~&gt; 2.8.0</code></pre>
<p>Run <code>shards install</code></p>
<h2><a id="lucky-example" class="anchor" href="#lucky-example">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Lucky example</h2>
<p>To help better illustrate how the entire setup looks, we'll use the <a href="https://luckyframework.org">lucky web framework</a>, but this will work in any Crystal web framework.</p>
<h3><a id="load-the-shard" class="anchor" href="#load-the-shard">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Load the shard</h3>
<pre><code class="language-crystal"><span class="c"># src/shards.cr</span>

<span class="k">require</span> <span class="s">&quot;cable&quot;</span>
<span class="k">require</span> <span class="s">&quot;cable/backend/redis/backend&quot;</span></code></pre>
<h3><a id="mount-the-middleware" class="anchor" href="#mount-the-middleware">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Mount the middleware</h3>
<p>Add the <code><a href="Cable/Handler.html">Cable::Handler</a></code> before <code>Lucky::RouteHandler</code></p>
<pre><code class="language-crystal"><span class="c"># src/app_server.cr</span>

<span class="k">class</span> <span class="t">AppServer</span> <span class="o">&lt;</span> <span class="t">Lucky</span><span class="t">::</span><span class="t">BaseAppServer</span>
  <span class="k">def</span> <span class="m">middleware</span>
    [
      <span class="t">Cable</span><span class="t">::</span><span class="t">Handler</span>(<span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Connection</span>).new, <span class="c"># place before the middleware below</span>
      <span class="t">Honeybadger</span><span class="t">::</span><span class="t">Handler</span>.new,
      <span class="t">Lucky</span><span class="t">::</span><span class="t">ErrorHandler</span>.new(action: <span class="t">Errors</span><span class="t">::</span><span class="t">Show</span>),
      <span class="t">Lucky</span><span class="t">::</span><span class="t">RouteHandler</span>.new,
    ]
   <span class="k">end</span>
<span class="k">end</span></code></pre>
<h3><a id="configure-cable-settings" class="anchor" href="#configure-cable-settings">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Configure cable settings</h3>
<p>After that, you can configure your <code><a href="Cable.html">Cable</a> server</code>. The defaults are:</p>
<pre><code class="language-crystal"><span class="c"># config/cable.cr</span>

<span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.route <span class="o">=</span> <span class="s">&quot;/cable&quot;</span>    <span class="c"># the URL your JS Client will connect</span>
  settings.token <span class="o">=</span> <span class="s">&quot;token&quot;</span>     <span class="c"># The query string parameter used to get the token</span>
  settings.url <span class="o">=</span> <span class="t">ENV</span>.fetch(<span class="s">&quot;REDIS_URL&quot;</span>, <span class="s">&quot;redis://localhost:6379&quot;</span>)

  <span class="c"># See Vanilla JS example below for more info</span>
  settings.disable_sec_websocket_protocol_header <span class="o">=</span> <span class="n">false</span>

  <span class="c"># stability settings</span>
  settings.redis_ping_interval <span class="o">=</span> <span class="n">15</span>.seconds
  settings.restart_error_allowance <span class="o">=</span> <span class="n">20</span>

  <span class="c"># DEPRECATED!</span>
  <span class="c"># only use if you are using stefanwille/crystal-redis</span>
  <span class="c"># AND you want to use the connection pool</span>
  <span class="c"># Use a single publish connection by default.</span>
  <span class="c"># settings.pool_redis_publish = false # set to `true` to enable a pooled connection on publish</span>
  <span class="c"># settings.redis_pool_size = 5</span>
  <span class="c"># settings.redis_pool_timeout = 5.0</span>
<span class="k">end</span></code></pre>
<h3><a id="configure-logging-level" class="anchor" href="#configure-logging-level">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Configure logging level</h3>
<p>You may want to tune how to report logging.</p>
<pre><code class="language-crystal"><span class="c"># config/log.cr</span>

log_levels <span class="o">=</span> {
  <span class="s">&quot;debug&quot;</span> <span class="o">=&gt;</span> <span class="t">Log</span><span class="t">::</span><span class="t">Severity</span><span class="t">::</span><span class="t">Debug</span>,
  <span class="s">&quot;info&quot;</span>  <span class="o">=&gt;</span> <span class="t">Log</span><span class="t">::</span><span class="t">Severity</span><span class="t">::</span><span class="t">Info</span>,
  <span class="s">&quot;error&quot;</span> <span class="o">=&gt;</span> <span class="t">Log</span><span class="t">::</span><span class="t">Severity</span><span class="t">::</span><span class="t">Error</span>,
}

<span class="c"># use the `CABLE_DEBUG_LEVEL` env var to choose any of the 3 log levels above</span>
<span class="t">Cable</span><span class="t">::</span><span class="t">Logger</span>.level <span class="o">=</span> log_levels[<span class="t">ENV</span>.fetch(<span class="s">&quot;CABLE_DEBUG_LEVEL&quot;</span>, <span class="s">&quot;info&quot;</span>)]</code></pre>
<p>Alternatively, use a global log level which matches you application log code also.</p>
<p>See <a href="https://crystal-lang.org/api/1.6.1/Log.html#configure-logging-from-environment-variables">Crystal API docs</a> for more details..</p>
<pre><code class="language-crystal"><span class="c"># config/log.cr</span>

<span class="c"># use the `LOG_LEVEL` env var</span>

<span class="t">Cable</span><span class="t">::</span><span class="t">Logger</span>.setup_from_env(default_level: <span class="n">:warn</span>)</code></pre>
<blockquote>
<p><span class="flag purple">NOTE</span>  The volume of logs produced are high... If log costs are a concern, use <code>warn</code> level to only receive critical logs</p>
</blockquote>
<h3><a id="setup-the-main-application-connection-and-channel-classes" class="anchor" href="#setup-the-main-application-connection-and-channel-classes">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Setup the main application connection and channel classes</h3>
<p>Then you need to implement a few classes.</p>
<p>The connection class is how you are going to handle connections. It's referenced in the <code>src/app_server.cr</code> file when creating the handler.</p>
<pre><code class="language-crystal"><span class="c"># src/channels/application_cable/connection.cr</span>

<span class="k">module</span> <span class="t">ApplicationCable</span>
  <span class="k">class</span> <span class="t">Connection</span> <span class="o">&lt;</span> <span class="t">Cable</span><span class="t">::</span><span class="t">Connection</span>
    <span class="c"># You need to specify how you identify the class, using something like:</span>
    <span class="c"># Remembering that it must be a String</span>
    <span class="c"># Tip: Use your `User#id` converted to String</span>
    identified_by <span class="n">:identifier</span>

    <span class="c"># If you&#39;d like to keep a `User` instance together with the Connection, so</span>
    <span class="c"># there&#39;s no need to fetch from the database all the time, you can use the</span>
    <span class="c"># `owned_by` instruction</span>
    owned_by current_user : <span class="t">User</span>

    <span class="k">def</span> <span class="m">connect</span>
      <span class="t">UserToken</span>.decode_user_id(token.to_s).try <span class="k">do</span> <span class="o">|</span>user_id<span class="o">|</span>
        <span class="k">self</span>.identifier <span class="o">=</span> user_id.to_s
        <span class="k">self</span>.current_user <span class="o">=</span>  <span class="t">UserQuery</span>.find(user_id)
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Then you need you a base channel to make it easy to inherit your app's Cable logic.</p>
<pre><code class="language-crystal"><span class="c"># src/channels/application_cable/channel.cr</span>

<span class="k">module</span> <span class="t">ApplicationCable</span>
  <span class="k">class</span> <span class="t">Channel</span> <span class="o">&lt;</span> <span class="t">Cable</span><span class="t">::</span><span class="t">Channel</span>
    <span class="c"># some potential shared logic or helpers</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<h3><a id="create-your-app-channels" class="anchor" href="#create-your-app-channels">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Create your app channels</h3>
<p><strong>Kitchen sink example</strong></p>
<p>Then create your cables, as much as your want!! Let's set up a <code>ChatChannel</code> as an example:</p>
<pre><code class="language-crystal"><span class="c"># src/channels/chat_channel.cr</span>

<span class="k">class</span> <span class="t">ChatChannel</span> <span class="o">&lt;</span> <span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="k">def</span> <span class="m">subscribed</span>
    <span class="c"># We don&#39;t support stream_for, needs to generate your own unique string</span>
    stream_from <span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">receive</span>(data)
    broadcast_message <span class="o">=</span> {} <span class="k">of</span> <span class="t">String</span> <span class="o">=&gt;</span> <span class="t">String</span>
    broadcast_message[<span class="s">&quot;message&quot;</span>] <span class="o">=</span> data[<span class="s">&quot;message&quot;</span>].to_s
    broadcast_message[<span class="s">&quot;current_user_id&quot;</span>] <span class="o">=</span> connection.identifier
    <span class="t">ChatChannel</span>.broadcast_to(<span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>, broadcast_message)
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">perform</span>(action, action_params)
    user <span class="o">=</span> <span class="t">UserQuery</span>.new.find(connection.identifier)
    <span class="c"># Perform actions on a user object. For example, you could manage</span>
    <span class="c"># its status by adding some .away and .status methods on it like below</span>
    <span class="c"># user.away if action == &quot;away&quot;</span>
    <span class="c"># user.status(action_params[&quot;status&quot;]) if action == &quot;status&quot;</span>
    <span class="t">ChatChannel</span>.broadcast_to(<span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>, {
      <span class="s">&quot;user&quot;</span>      <span class="o">=&gt;</span> user.email,
      <span class="s">&quot;performed&quot;</span> <span class="o">=&gt;</span> action.to_s,
    })
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">unsubscribed</span>
    <span class="c">#  Perform any action after the client closes the connection.</span>
    user <span class="o">=</span> <span class="t">UserQuery</span>.new.find(connection.identifier)

    <span class="c"># You could, for example, call any method on your user</span>
    <span class="c"># user.logout</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p><strong>Rejection example</strong></p>
<p>Reject channel subscription if the request is invalid:</p>
<pre><code class="language-crystal"><span class="c"># src/channels/chat_channel.cr</span>

<span class="k">class</span> <span class="t">ChatChannel</span> <span class="o">&lt;</span> <span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="k">def</span> <span class="m">subscribed</span>
    reject <span class="k">if</span> user_not_allowed_to_join_chat_room?

    stream_from <span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p><strong>Callbacks example</strong></p>
<p>Use callbacks to perform actions or transmit messages once the connection/channel has been subscribed.</p>
<pre><code class="language-crystal"><span class="c"># src/channels/chat_channel.cr</span>

<span class="k">class</span> <span class="t">ChatChannel</span> <span class="o">&lt;</span> <span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="c"># you can name these callbacks anything you want...</span>
  <span class="c"># `after_subscribed` can accept 1 or more callbacks to be run in order</span>
  after_subscribed <span class="n">:broadcast_welcome_pack_to_single_subscribed_user</span>,
                   <span class="n">:announce_user_joining_to_everyone_else_in_the_channel</span>,
                   <span class="n">:process_some_stuff</span>

  <span class="k">def</span> <span class="m">subscribed</span>
    stream_from <span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>

  <span class="c"># If you ONLY need to send the current_user a message</span>
  <span class="c"># and none of the other subscribers</span>
  <span class="c">#</span>
  <span class="c"># use -&gt; transmit(message), which accepts Hash(String, String) or String</span>
  <span class="k">def</span> <span class="m">broadcast_welcome_pack_to_single_subscribed_user</span>
    transmit({ <span class="s">&quot;welcome_pack&quot;</span> <span class="o">=&gt;</span> <span class="s">&quot;some cool stuff for this single user&quot;</span> })
  <span class="k">end</span>

  <span class="c"># On the other hand,</span>
  <span class="c"># if you want to broadcast a message</span>
  <span class="c"># to all subscribers connected to this channel</span>
  <span class="c">#</span>
  <span class="c"># use -&gt; broadcast(message), which accepts Hash(String, String) or String</span>
  <span class="k">def</span> <span class="m">announce_user_joining_to_everyone_else_in_the_channel</span>
    broadcast(<span class="s">&quot;username xyz just joined&quot;</span>)
  <span class="k">end</span>

  <span class="c"># you don&#39;t need to use the transmit functionality</span>
  <span class="k">def</span> <span class="m">process_some_stuff</span>
    send_welcome_email_to_user
    update_their_profile
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<h2><a id="redis-1" class="anchor" href="#redis-1">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Redis</h2>
<p>Redis is awesome, but it has complexities that need to be considered;</p>
<ol>
<li>Redis Pub/Sub works really well until you lose the connection...</li>
<li>Redis connections can go stale without activity.</li>
<li>Redis connection TCP issues can cause unstable connections.</li>
<li>Redis DB's have a buffer related to the message sizes called <a href="https://redis.io/docs/reference/clients/#output-buffer-limits">Output Buffer Limits</a>. Exceeding this buffer will not disconnect the connection. It just yields it dead. You cannot know about this except by monitoring logs/metrics.</li>
</ol>
<p>Here are some ways this shard can help with this.</p>
<h3><a id="restarting-the-server" class="anchor" href="#restarting-the-server">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Restarting the server</h3>
<p>When the first connection is made, the cable server spawns a single pub/sub connection for all subscriptions.
If the connection dies at any point, the server will continue to throw errors unless someone manually restarts the server...</p>
<p>The cable server provides an automated failure rate monitoring/restart function to automate the restart process.</p>
<p>When the server encounters (n) errors are trying to connect to the Redis connection, it restarts the server.
The error rate allowance avoids a vicious cycle i.e. (n) clients attempting to connect vs server restarts while Redis is down.
Generally, if the Redis connection is down, you'll exceed this error allowance quickly. So you may encounter severe back-to-back restarts if Redis is down for a substantial time.
This is expected for any system which uses a Redis backed, and Redis goes down. However, once Redis covers, Cable will self-heal and re-establish all the socket connections.</p>
<blockquote>
<p><span class="flag purple">NOTE</span>  The automated restart process will also kill all the current client WS connections.
However, this trade-off allows a fault-tolerant system vs leaving a dead Redis connection hanging around with no pub/sub activity.</p>
</blockquote>
<p><strong>Restart allowance settings</strong></p>
<p>You can change this setting. However, we advise not going below 20.</p>
<pre><code class="language-crystal"><span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.restart_error_allowance <span class="o">=</span> <span class="n">20</span> <span class="c"># default is 20. Use 0 to disable restarts</span>
<span class="k">end</span></code></pre>
<blockquote>
<p><span class="flag purple">NOTE</span>  An error log <code>Cable.restart</code> will be invoked whenever a restart happens. We highly advise you to monitor these logs.</p>
</blockquote>
<h3><a id="maintain-redis-connection-activity" class="anchor" href="#maintain-redis-connection-activity">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Maintain Redis connection activity</h3>
<p>When the first connection is made, the cable server starts a Redis PING/PONG task, which runs every 15 seconds. This helps to keep the Redis connection from going stale.</p>
<p>You can change this setting. However, we advise not going over 60 seconds.</p>
<pre><code class="language-crystal"><span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.redis_ping_interval <span class="o">=</span> <span class="n">15</span>.seconds <span class="c"># default is 15.</span>
<span class="k">end</span></code></pre>
<h3><a id="enable-pooling-and-tcp-keepalive" class="anchor" href="#enable-pooling-and-tcp-keepalive">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Enable pooling and TCP keepalive</h3>
<p>The Redis officially supported shard allows us to create a connection pool and also enable TCP keepalive settings.</p>
<p><strong>Recommended setup</strong></p>
<p>Start simple with the following settings.
The Redis shard has pretty good default settings for pooling and TCP keepalive.</p>
<pre><code class="language-crystal"><span class="c"># .env</span>

<span class="t">REDIS_URL</span>: <span class="o">&lt;</span>redis_connection_string<span class="o">&gt;</span>?keepalive<span class="o">=</span><span class="n">true</span></code></pre>
<pre><code class="language-crystal"><span class="c"># config/cable.cr</span>

<span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.url <span class="o">=</span> <span class="t">ENV</span>.fetch(<span class="s">&quot;REDIS_URL&quot;</span>, <span class="s">&quot;redis://localhost:6379&quot;</span>)
<span class="k">end</span></code></pre>
<blockquote>
<p><span class="flag purple">NOTE</span>  This is not enabled by default. You must pass this param to the connection string to ensure this is enabled.</p>
</blockquote>
<p>See the <a href="https://github.com/jgaskins/redis#connection-pool">full docs</a> on the pooling and TCP keepalive capabilities.</p>
<h3><a id="increase-your-redis-output-buffer-limits" class="anchor" href="#increase-your-redis-output-buffer-limits">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Increase your Redis <a href="https://redis.io/docs/reference/clients/#output-buffer-limits">Output Buffer Limits</a></h3>
<blockquote>
<p>Technically, this shard cannot help with this.</p>
</blockquote>
<p>Exceeding this buffer should be avoided to ensure a stable pub/sub connection.</p>
<p>Options;</p>
<ol>
<li>Double or triple this setting on your Redis DB. 32Mb is usually the default.</li>
<li>Ensure you truncate the message sizes client side.</li>
</ol>
<h2><a id="error-handling" class="anchor" href="#error-handling">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Error handling</h2>
<p>You can setup a hook to report errors to any 3rd party service you choose.</p>
<pre><code class="language-crystal"><span class="c"># config/cable.cr</span>
<span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.on_error <span class="o">=</span> <span class="o">-&gt;</span>(exception : <span class="t">Exception</span>, message : <span class="t">String</span>) <span class="k">do</span>
    <span class="c"># new 3rd part service handler</span>
    <span class="t">ExceptionService</span>.notify(exception, message: message)
    <span class="c"># default logic</span>
    <span class="t">Cable</span><span class="t">::</span><span class="t">Logger</span>.error(exception: exception) { message }
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p><strong>Default Handler</strong></p>
<pre><code class="language-crystal"><span class="t">Habitat</span>.create <span class="k">do</span>
  setting on_error : <span class="t">Proc</span>(<span class="t">Exception</span>, <span class="t">String</span>, <span class="t">Nil</span>) <span class="o">=</span> <span class="o">-&gt;</span>(exception : <span class="t">Exception</span>, message : <span class="t">String</span>) <span class="k">do</span>
    <span class="t">Cable</span><span class="t">::</span><span class="t">Logger</span>.error(exception: exception) { message }
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<blockquote>
<p><span class="flag purple">NOTE</span>  The message field will contain details regarding which class/method raised the error</p>
</blockquote>
<h2><a id="client-side" class="anchor" href="#client-side">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Client-Side</h2>
<p>Check below on the JavaScript section how to communicate with the Cable backend.</p>
<h3><a id="java-script" class="anchor" href="#java-script">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>JavaScript</h3>
<p>It works with <a href="https://www.npmjs.com/package/actioncable">ActionCable</a> JS Client out-of-the-box!! Yeah, that's really cool no? If you need to adapt, make a hack, or something like that?!</p>
<p>No, you don't need it! Just read the few lines below and start playing with Cable in 5 minutes!</p>
<h3><a id="action-cable-js-example" class="anchor" href="#action-cable-js-example">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>ActionCable JS Example</h3>
<p><a href="examples/action-cable-js-client.md">examples/action-cable-js-client.md</a></p>
<h3><a id="vanilla-js-examples" class="anchor" href="#vanilla-js-examples">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Vanilla JS Examples</h3>
<p>If you want to use this shard with iOS clients or vanilla JS using react etc., there is an example in the <a href="examples/">examples</a> folder.</p>
<blockquote>
<p>Note - If you are using a vanilla - non-action-cable JS client, you may want to disable the action cable response headers as they cause issues for clients who don't know how to handle them. Set a Habitat disable_sec_websocket_protocol_header like so to disable those headers;</p>
</blockquote>
<pre><code class="language-crystal"><span class="c"># config/cable.cr</span>

<span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.disable_sec_websocket_protocol_header <span class="o">=</span> <span class="n">true</span>
<span class="k">end</span></code></pre>
<h2><a id="debugging" class="anchor" href="#debugging">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Debugging</h2>
<p>You can create a JSON endpoint to ping the server and check how things are going.</p>
<pre><code class="language-crystal"><span class="c"># src/actions/debug/index.cr</span>

<span class="k">class</span> <span class="t">Debug</span><span class="t">::</span><span class="t">Index</span> <span class="o">&lt;</span> <span class="t">ApiAction</span>
  <span class="k">include</span> <span class="t">RequireAuthToken</span>

  get <span class="s">&quot;/debug&quot;</span> <span class="k">do</span>
    json(<span class="t">Cable</span>.server.debug_json) <span class="c"># Cable.server.debug_json is provided by this shard</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Alternatively, you can ping Redis directly using the redis-cli as follows;</p>
<pre><code class="language-bash">PUBLISH _internal debug</code></pre>
<p>This will dump a debug status into the logs.</p>
<h2><a id="todo" class="anchor" href="#todo">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>TODO</h2>
<p>After reading the docs, I realized I'm using some weird naming for variables/methods, so</p>
<ul>
<li>[x] Need to make a connection use an identifier</li>
<li>[x] Add <code>identified_by identifier</code> to <code><a href="Cable/Connection.html">Cable::Connection</a></code></li>
<li>[x] Give better methods to reject a connection</li>
<li>[x] Refactor, Connection class, is so bloated</li>
<li>[ ] Allow tracing and observability hooks.</li>
<li>[ ] Allow external bug tracking hooks.</li>
<li>[ ] Allow custom JSON formatted logs.</li>
<li>[ ] Clean up of naming to make it easier for others to contribute.</li>
<li>[ ] Add an async/local adapter (make tests, development, and small deploys simpler)</li>
<li>[ ] Add PostgreSQL backend</li>
</ul>
<h2><a id="first-class-citizen" class="anchor" href="#first-class-citizen">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>First Class Citizen</h2>
<ul>
<li>[ ] Better integrate with Lucky, maybe with generators or something else?</li>
<li>[ ] Add support for Kemal</li>
<li>[ ] Add support for Amber</li>
</ul>
<p>The idea is to create different modules, <code>Cable::Lucky</code>, <code>Cable::Kemal</code>, <code>Cable::Amber</code>, and make them easy to use with any crystal web framework.</p>
<h2><a id="contributing" class="anchor" href="#contributing">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Contributing</h2>
<p>You know, fork-branch-push-pr 😉 don't be shy. Participate as you want!</p>
</div>
</body>
</html>
