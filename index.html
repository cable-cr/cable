<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 1.1.1">
<meta name="crystal_docs.project_version" content="master">
<meta name="crystal_docs.project_name" content="cable">



<link href="css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/doc.js"></script>

  <meta name="repository-name" content="cable">
  <title>cable master</title>
  <script type="text/javascript">
  CrystalDocs.base_path = "";
  </script>
</head>
<body>

<svg class="hidden">
  <symbol id="octicon-link" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
  </symbol>
</svg>
<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="project-summary">
      <h1 class="project-name">
        <a href="index.html">
          cable
        </a>
      </h1>

      <span class="project-version">
        master
      </span>
    </div>
  </div>

  <div class="search-results hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="cable/Cable" data-name="cable">
      <a href="Cable.html">Cable</a>
      
        <ul>
  
  <li class="parent " data-id="cable/Cable/Channel" data-name="cable::channel">
      <a href="Cable/Channel.html">Channel</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/Channel/CloseRedisFiber" data-name="cable::channel::closeredisfiber">
      <a href="Cable/Channel/CloseRedisFiber.html">CloseRedisFiber</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Cable/Channels" data-name="cable::channels">
      <a href="Cable/Channels.html">Channels</a>
      
    </li>
  
  <li class="parent " data-id="cable/Cable/Connection" data-name="cable::connection">
      <a href="Cable/Connection.html">Connection</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/Connection/UnathorizedConnectionException" data-name="cable::connection::unathorizedconnectionexception">
      <a href="Cable/Connection/UnathorizedConnectionException.html">UnathorizedConnectionException</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Cable/Debug" data-name="cable::debug">
      <a href="Cable/Debug.html">Debug</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/HabitatSettings" data-name="cable::habitatsettings">
      <a href="Cable/HabitatSettings.html">HabitatSettings</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Handler" data-name="cable::handler(t)">
      <a href="Cable/Handler.html">Handler</a>
      
    </li>
  
  <li class="parent " data-id="cable/Cable/Payload" data-name="cable::payload">
      <a href="Cable/Payload.html">Payload</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/Payload/PARAMS" data-name="cable::payload::params">
      <a href="Cable/Payload/PARAMS.html">PARAMS</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Payload/RESULT" data-name="cable::payload::result">
      <a href="Cable/Payload/RESULT.html">RESULT</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Cable/RedisPinger" data-name="cable::redispinger">
      <a href="Cable/RedisPinger.html">RedisPinger</a>
      
    </li>
  
  <li class=" " data-id="cable/Cable/Server" data-name="cable::server">
      <a href="Cable/Server.html">Server</a>
      
    </li>
  
  <li class="parent " data-id="cable/Cable/WebsocketPinger" data-name="cable::websocketpinger">
      <a href="Cable/WebsocketPinger.html">WebsocketPinger</a>
      
        <ul>
  
  <li class=" " data-id="cable/Cable/WebsocketPinger/PingStoppedException" data-name="cable::websocketpinger::pingstoppedexception">
      <a href="Cable/WebsocketPinger/PingStoppedException.html">PingStoppedException</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="cable/Redis" data-name="redis">
      <a href="Redis.html">Redis</a>
      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1><a id="cable" class="anchor" href="#cable">  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Cable</h1>
<p><a href="https://github.com/cable-cr/cable/actions/workflows/ci.yml"><img src="https://github.com/cable-cr/cable/actions/workflows/ci.yml/badge.svg" alt="ci workflow" /></a></p>
<p>It's like <a href="https://guides.rubyonrails.org/action_cable_overview.html">ActionCable</a> (100% compatible with JS Client), but you know, for Crystal</p>
<h2><a id="installation" class="anchor" href="#installation">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Installation</h2>
<ol>
<li>
<p>Add the dependency to your <code>shard.yml</code>:</p>
<pre><code class="language-yaml">dependencies:
  cable:
    github: cable-cr/cable</code></pre>
</li>
<li>
<p>Run <code>shards install</code></p>
</li>
</ol>
<h2><a id="usage" class="anchor" href="#usage">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Usage</h2>
<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;cable&quot;</span></code></pre>
<h3><a id="lucky-example" class="anchor" href="#lucky-example">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Lucky example</h3>
<p>On your <code>src/app_server.cr</code> add the <code><a href="Cable/Handler.html">Cable::Handler</a></code> before <code>Lucky::RouteHandler</code></p>
<pre><code class="language-crystal"><span class="k">class</span> <span class="t">AppServer</span> <span class="o">&lt;</span> <span class="t">Lucky</span><span class="t">::</span><span class="t">BaseAppServer</span>
  <span class="k">def</span> <span class="m">middleware</span>
    [
      <span class="t">Cable</span><span class="t">::</span><span class="t">Handler</span>(<span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Connection</span>).<span class="k">new</span>, <span class="c"># place before the middleware below</span>
      <span class="t">Honeybadger</span><span class="t">::</span><span class="t">Handler</span>.<span class="k">new</span>,
      <span class="t">Lucky</span><span class="t">::</span><span class="t">ErrorHandler</span>.<span class="k">new</span>(action: <span class="t">Errors</span><span class="t">::</span><span class="t">Show</span>),
      <span class="t">Lucky</span><span class="t">::</span><span class="t">RouteHandler</span>.<span class="k">new</span>,
    ]
   <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>After that, you can configure your <code><a href="Cable.html">Cable</a></code>, the defaults are:</p>
<pre><code class="language-crystal"><span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.route <span class="o">=</span> <span class="s">&quot;/cable&quot;</span>    <span class="c"># the URL your JS Client will connect</span>
  settings.token <span class="o">=</span> <span class="s">&quot;token&quot;</span>     <span class="c"># The query string parameter used to get the token</span>
  settings.url <span class="o">=</span> <span class="t">ENV</span>.fetch(<span class="s">&quot;REDIS_URL&quot;</span>, <span class="s">&quot;redis://localhost:6379&quot;</span>)

  <span class="c"># See Vanilla JS example below for more info</span>
  settings.disable_sec_websocket_protocol_header <span class="o">=</span> <span class="n">false</span>

  <span class="c"># Use a single publish connection by default.</span>
  settings.pool_redis_publish <span class="o">=</span> <span class="n">false</span> <span class="c"># set to `true` to enable a pooled connection on publish</span>
  settings.redis_pool_size <span class="o">=</span> <span class="n">5</span>
  settings.redis_pool_timeout <span class="o">=</span> <span class="n">5.0</span>
  settings.redis_ping_interval <span class="o">=</span> <span class="n">15</span>.seconds
  settings.restart_error_allowance <span class="o">=</span> <span class="n">20</span>
<span class="k">end</span></code></pre>
<p>You may want to tune how to report logging</p>
<pre><code class="language-crystal"><span class="c"># config/log.cr</span>

log_levels <span class="o">=</span> {
  <span class="s">&quot;debug&quot;</span> => <span class="t">Log</span><span class="t">::</span><span class="t">Severity</span><span class="t">::</span><span class="t">Debug</span>,
  <span class="s">&quot;info&quot;</span>  => <span class="t">Log</span><span class="t">::</span><span class="t">Severity</span><span class="t">::</span><span class="t">Info</span>,
  <span class="s">&quot;error&quot;</span> => <span class="t">Log</span><span class="t">::</span><span class="t">Severity</span><span class="t">::</span><span class="t">Error</span>,
}

<span class="c"># use the `CABLE_DEBUG_LEVEL` env var to choose any of the 3 log levels above</span>
<span class="t">Cable</span><span class="t">::</span><span class="t">Logger</span>.level <span class="o">=</span> log_levels[<span class="t">ENV</span>.fetch(<span class="s">&quot;CABLE_DEBUG_LEVEL&quot;</span>, <span class="s">&quot;info&quot;</span>)]</code></pre>
<p>Then you need to implement a few classes</p>
<p>The connection class is how you are gonna handle connections, it's referenced on the <code>src/app_server.cr</code> when creating the handler.</p>
<pre><code class="language-crystal"><span class="k">module</span> <span class="t">ApplicationCable</span>
  <span class="k">class</span> <span class="t">Connection</span> <span class="o">&lt;</span> <span class="t">Cable</span><span class="t">::</span><span class="t">Connection</span>
    <span class="c"># You need to specify how you identify the class, using something like:</span>
    <span class="c"># Remembering that it must, be a String</span>
    <span class="c"># Tip: Use your `User#id` converted to String</span>
    identified_by <span class="n">:identifier</span>

    <span class="c"># If you&#39;d like to keep a `User` instance together with the Connection, so</span>
    <span class="c"># there&#39;s no need to fetch from the database all the time, you can use the</span>
    <span class="c"># `owned_by` instruction</span>
    owned_by current_user : <span class="t">User</span>

    <span class="k">def</span> <span class="m">connect</span>
      <span class="t">UserToken</span>.decode_user_id(token.to_s).try <span class="k">do</span> <span class="o">|</span>user_id<span class="o">|</span>
        <span class="k">self</span>.identifier <span class="o">=</span> user_id.to_s
        <span class="k">self</span>.current_user <span class="o">=</span>  <span class="t">UserQuery</span>.find(user_id)
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Then you need your base channel, just to make easy to aggregate your app's cables logic</p>
<pre><code class="language-crystal"><span class="k">module</span> <span class="t">ApplicationCable</span>
  <span class="k">class</span> <span class="t">Channel</span> <span class="o">&lt;</span> <span class="t">Cable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Then create your cables, as much as your want!! Let's setup a <code>ChatChannel</code> as example:</p>
<pre><code class="language-crystal"><span class="k">class</span> <span class="t">ChatChannel</span> <span class="o">&lt;</span> <span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="k">def</span> <span class="m">subscribed</span>
    <span class="c"># We don&#39;t support stream_for, needs to generate your own unique string</span>
    stream_from <span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">receive</span>(data)
    broadcast_message <span class="o">=</span> {} <span class="k">of</span> <span class="t">String</span> => <span class="t">String</span>
    broadcast_message[<span class="s">&quot;message&quot;</span>] <span class="o">=</span> data[<span class="s">&quot;message&quot;</span>].to_s
    broadcast_message[<span class="s">&quot;current_user_id&quot;</span>] <span class="o">=</span> connection.identifier
    <span class="t">ChatChannel</span>.broadcast_to(<span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>, broadcast_message)
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">perform</span>(action, action_params)
    user <span class="o">=</span> <span class="t">UserQuery</span>.<span class="k">new</span>.find(connection.identifier)
    <span class="c"># Perform action on your user object. For example, you could manage</span>
    <span class="c"># its status by adding some .away and .status methods on it like below</span>
    <span class="c"># user.away if action == &quot;away&quot;</span>
    <span class="c"># user.status(action_params[&quot;status&quot;]) if action == &quot;status&quot;</span>
    <span class="t">ChatChannel</span>.broadcast_to(<span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>, {
      <span class="s">&quot;user&quot;</span>      => user.email,
      <span class="s">&quot;performed&quot;</span> => action.to_s,
    })
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">unsubscribed</span>
    <span class="c"># You can do any action after client closes connection</span>
    user <span class="o">=</span> <span class="t">UserQuery</span>.<span class="k">new</span>.find(connection.identifier)

    <span class="c"># You could for example call any method on your user like a .logout one</span>
    <span class="c"># user.logout</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Reject channel subscription if the request is invalid:</p>
<pre><code class="language-crystal"><span class="k">class</span> <span class="t">ChatChannel</span> <span class="o">&lt;</span> <span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="k">def</span> <span class="m">subscribed</span>
    reject <span class="k">if</span> user_not_allowed_to_join_chat_room?

    stream_from <span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Use callbacks to perform actions or transmit messages once the connection/channel has been subscribed.</p>
<pre><code class="language-crystal"><span class="k">class</span> <span class="t">ChatChannel</span> <span class="o">&lt;</span> <span class="t">ApplicationCable</span><span class="t">::</span><span class="t">Channel</span>
  <span class="c"># you can name these callbacks anything you want...</span>
  <span class="c"># `after_subscribed` can accept 1 or more callbacks to be run in order</span>
  after_subscribed <span class="n">:broadcast_welcome_pack_to_single_subscribed_user</span>,
                   <span class="n">:announce_user_joining_to_everyone_else_in_the_channel</span>,
                   <span class="n">:process_some_stuff</span>

  <span class="k">def</span> <span class="m">subscribed</span>
    stream_from <span class="s">&quot;chat_</span><span class="i">#{</span>params[<span class="s">&quot;room&quot;</span>]<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>

  <span class="c"># If you want to ONLY send the current_user a message</span>
  <span class="c"># and none of the other subscribers</span>
  <span class="c">#</span>
  <span class="c"># use -&gt; transmit(message), which accepts Hash(String, String) or String</span>
  <span class="k">def</span> <span class="m">broadcast_welcome_pack_to_single_subscribed_user</span>
    transmit({ <span class="s">&quot;welcome_pack&quot;</span> => <span class="s">&quot;some cool stuff for this single user&quot;</span> })
  <span class="k">end</span>

  <span class="c"># On the other hand,</span>
  <span class="c"># if you want to broadcast a message</span>
  <span class="c"># to all subscribers connected to this channel</span>
  <span class="c">#</span>
  <span class="c"># use -&gt; broadcast(message), which accepts Hash(String, String) or String</span>
  <span class="k">def</span> <span class="m">announce_user_joining_to_everyone_else_in_the_channel</span>
    broadcast(<span class="s">&quot;username xyz just joined&quot;</span>)
  <span class="k">end</span>

  <span class="c"># you don&#39;t need to use transmit functionality</span>
  <span class="k">def</span> <span class="m">process_some_stuff</span>
    send_welcome_email_to_user
    update_their_profile
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<h2><a id="redis" class="anchor" href="#redis">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Redis</h2>
<p>Redis has complexities that need to be considered;</p>
<ol>
<li>Redis Pub/Sub works really well until you lose the connection...</li>
<li>Redis connections can go stale without activity.</li>
<li>Redis DB's have a buffer related to the message sizes called <a href="https://redis.io/docs/reference/clients/#output-buffer-limits">Output Buffer Limits</a>. Exceeding this buffer will not disconnect the connection. It just yields it dead. You cannot know about this except by monitoring logs/metrics.</li>
</ol>
<p>Here are some ways this shard can help with this.</p>
<h3><a id="restarting-the-server" class="anchor" href="#restarting-the-server">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Restarting the server</h3>
<p>When the first connection is made, the cable server spawns a single pub/sub connection for all subscriptions.
If the connection dies at any point, the server will continue to throw errors unless someone manually restarts the server...</p>
<p>The cable server provides an automated failure rate monitoring/restart function to automate the restart process.</p>
<p>When the server encounters (n) errors are trying to connect to the Redis connection, it restarts the server.
The error rate allowance avoids a vicious cycle &gt; of clients attempting to connect vs server restarts while Redis is down.
Generally, if the Redis connection is down, you'll exceed this error allowance quickly. So you may encounter severe back-to-back restarts if Redis is down for a substantial time.</p>
<blockquote>
<p><span class="flag purple">NOTE</span>  The automated restart process will also kill all the current client WS connections.
However, this trade-off allows a fault-tolerant system vs leaving a dead Redis connection hanging around with no pub/sub activity.</p>
</blockquote>
<p>You can change this setting. However, we advise not going below 20.</p>
<pre><code class="language-crystal"><span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
 settings.restart_error_allowance <span class="o">=</span> <span class="n">20</span> <span class="c"># default is 20.</span>
 settings.restart_error_allowance <span class="o">=</span> <span class="n">0</span> <span class="c"># Use 0 to disable this</span>
<span class="k">end</span></code></pre>
<blockquote>
<p><span class="flag purple">NOTE</span>  An error log <code>Cable.restart</code> will be invoked whenever a restart happens. We highly advise you to monitor these logs.</p>
</blockquote>
<h3><a id="maintain-redis-connection-activity" class="anchor" href="#maintain-redis-connection-activity">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Maintain Redis connection activity</h3>
<p>When the first connection is made, the cable server starts a Redis PING/PONG task, which runs every 15 seconds. This helps to keep the Redis connection from going stale.</p>
<p>You can change this setting. However, we advise not going over 60 seconds.</p>
<pre><code class="language-crystal"><span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
 settings.redis_ping_interval <span class="o">=</span> <span class="n">15</span>.seconds <span class="c"># default is 15.</span>
<span class="k">end</span></code></pre>
<h3><a id="increase-your-redis-output-buffer-limits" class="anchor" href="#increase-your-redis-output-buffer-limits">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Increase your Redis <a href="https://redis.io/docs/reference/clients/#output-buffer-limits">Output Buffer Limits</a></h3>
<blockquote>
<p>Technically, this shard cannot help with this.</p>
</blockquote>
<p>Exceeding this buffer should be avoided to ensure a stable pub/sub connection.</p>
<p>Options;</p>
<ol>
<li>Double or triple this setting on your Redis DB. 32Mb is usually the default.</li>
<li>Ensure you truncate the message sizes client side.</li>
</ol>
<p>Check below on the JavaScript section how to communicate with the Cable backend</p>
<h2><a id="java-script" class="anchor" href="#java-script">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>JavaScript</h2>
<p>It works with <a href="https://www.npmjs.com/package/actioncable">ActionCable</a> JS Client out-of-the-box!! Yeah, that's really cool no? If you need to adapt, make a hack, or something like that?!</p>
<p>No, you don't need! Just read the few lines below and start playing with Cable in 5 minutes!</p>
<h3><a id="action-cable-js-example" class="anchor" href="#action-cable-js-example">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>ActionCable JS Example</h3>
<p><code>/examples/action-cable-js-client.md</code></p>
<h3><a id="vanilla-js-examples" class="anchor" href="#vanilla-js-examples">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Vanilla JS Examples</h3>
<p>If you want to use this shard with an iOS clients or vanilla JS using react etc. there is an example in the <code>/examples</code> folder.</p>
<blockquote>
<p>Note - If your using a vanilla - non action-cable JS client, you may want to disable the action cable response headers as they cause issues on the clients who don't know how to handle them. Set an Habitat disable_sec_websocket_protocol_header like so to disable those headers;</p>
</blockquote>
<pre><code class="language-crystal"><span class="c"># config/cable.cr</span>

<span class="t">Cable</span>.configure <span class="k">do</span> <span class="o">|</span>settings<span class="o">|</span>
  settings.disable_sec_websocket_protocol_header <span class="o">=</span> <span class="n">true</span>
<span class="k">end</span></code></pre>
<h2><a id="debugging" class="anchor" href="#debugging">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Debugging</h2>
<p>You can create a json endpoint to ping your server and check how things are going.</p>
<pre><code class="language-crystal">
<span class="c"># src/actions/debug/index.cr</span>

<span class="k">class</span> <span class="t">Debug</span><span class="t">::</span><span class="t">Index</span> <span class="o">&lt;</span> <span class="t">ApiAction</span>
  <span class="k">include</span> <span class="t">RequireAuthToken</span>

  get <span class="s">&quot;/debug&quot;</span> <span class="k">do</span>
    json(<span class="t">Cable</span>.server.debug_json) <span class="c"># Cable.server.debug_json is provided by this shard</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<p>Alternatively, you can ping redis directly using the redis-cli as follows;</p>
<pre><code class="language-bash">PUBLISH _internal debug</code></pre>
<p>This will dump a debug status into your logs</p>
<h2><a id="todo" class="anchor" href="#todo">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>TODO</h2>
<p>After reading the docs, I realized I'm using some weird naming for variables / methods, so</p>
<ul>
<li>[x] Need to make connection use identifier</li>
<li>[x] Add <code>identified_by identifier</code> to <code><a href="Cable/Connection.html">Cable::Connection</a></code></li>
<li>[x] Give better methods to reject a connection</li>
<li>[x] Refactor, Connection class is soooo bloated</li>
<li>[ ] Add an async/local adapter (make tests, development and small deploys simpler)</li>
</ul>
<h2><a id="first-class-citizen" class="anchor" href="#first-class-citizen">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>First Class Citizen</h2>
<ul>
<li>[ ] Better integrate with Lucky, maybe with generators, or something else?</li>
<li>[ ] Add support for Kemal</li>
<li>[ ] Add support for Amber</li>
</ul>
<p>Idea is create different modules, <code>Cable::Lucky</code>, <code>Cable::Kemal</code>, <code>Cable::Amber</code>, and make it easy to use with any crystal web framework</p>
<h2><a id="contributing" class="anchor" href="#contributing">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Contributing</h2>
<p>You know, fork-branch-push-pr ðŸ˜‰ don't be shy, participate as you want!</p>
</div>
</body>
</html>
